/*
Reads values from serial port, written to the port by Arduino.
The size of an ellipse changes according to the serial values.
Must assign the correct port, see instructions below.
*/

import processing.serial.*; //imports Serial library from Processing

Serial myPort; // creates object from Serial class
int val; // creates variable for data coming from serial port

PImage boat, sunbaby;

int columns, rows; //construction of grid
int scale = 20; //scale of each square on grid
int w = 1600; //width andv
int h = 1200; //height of grid

float flying = 20; //initializing speed

float[][] terrain; //terrain array

float transparency = 255;//alpha

float bgR; //color map
float bgG;
float bgB;
float vR;
float vG;
float vB;

void setup() {
size(1000, 800, P3D);
/*
We must tell Processing which port to read from.
Run the sketch and check your console to see the results of printArray(Serial.list());
and that is how you know the port to use.
On my Mac, it is port 2 and so I open Serial.list()[2].
*/

printArray(Serial.list()); // this line prints the port list to the console
String portName = Serial.list()[1]; //change the number in the [] for the port you need
myPort = new Serial(this, portName, 9600);

columns = w / scale; //defining width +
  rows = h / scale ; //height of grid
  terrain = new float[columns][rows]; //inputting columns/rows values
  sphereDetail(5); //quality of scene
  frameRate(24); //quality of scene
  
  boat = loadImage("sailboat.png"); //loading images
  sunbaby = loadImage("sun.png");

}

void draw(){
if ( myPort.available() > 0) { // If data is available,
val = myPort.read(); // read it and store it in val
}

bgR = map(val, 100, 200, 5, 170); //no squeeze = calm night
  bgG = map(val, 100, 200, 5, 240);
  bgB = map(val, 100, 200, 25, 250);
  background(bgR, bgG, bgB);
  
  noStroke(); //terrain stroke & lights
  lights();
  
  //TERRAIN MOVEMENT
  flying -= 0.005; //speed of terrain movement
  float yoff = flying; //offset
  for (int y = 0; y < rows; y=y+1) {
    float xoff=0;
    for (int x = 0; x < columns; x=x+1) {
      terrain[x][y] = map(noise(xoff, yoff), 0, 1, -100, 100); //picking random sets of values created by perlin noise
      //end numbers effect squeeze visual
     if (val < 100) { //if not squeezed = calm night sea
      xoff += 0.01;//flatten peaks
     } else { //if squeezed, then
        xoff += 0.5;//lift verteces to create peaks
     }
    }
    if (val < 100){
    yoff += 0.1;
    } else {
      yoff += 0.5;
    }
  }

  //ROTATE TERRAIN
  translate(width/2, height/2);//move x,y to center
  rotateX(PI/3); //tilt the terrain
  translate(-w/2, -h/2);//move more to center lmao
  
  println (val); //prints to Processing console
  
  VERTECES();
  SAILBOAT();
  SUN();
}

void VERTECES(){
  for (int y = 0; y < rows-1; y=y+1) {//rows-1 bc second to last row?
  beginShape(TRIANGLE_STRIP);
    for (int x = 0; x < columns; x=x+1) { //creating grid
    noStroke();
    
    //float volume = analyzer.analyze();
    vR = map(val, 0, 200, 6, 20);
    vG = map(val, 0, 200, 19, 160);
    vB = map(val, 0, 200, 66, 90);
    fill(vR, vG, vB);

      //texture(meadow); //texture of 
      vertex(x*scale, y*scale, terrain[x][y], 0, 0); // z values(peaks) generated by terrain array
      vertex(x*scale, (y+1)*scale, terrain[x][y+1], 100, 0); // [y+1] crosses verteces into triangle grid
      vertex(x*scale, y*scale, terrain[x][y], 100, 100); //extra verteces to map the
      vertex(x*scale, (y+1)*scale, terrain[x][y+1], 0, 100); //texture to each corner of grid
    }
     endShape();
  }
}

void SAILBOAT(){
  for (int y = 0; y < rows-1; y=y+39) { //adjusting end number:
    for (int x = 0; x < columns; x=x+28) { //effects amount of people (less is more?)
  pushMatrix();
  translate(x*scale, y*scale, terrain[x][y]); //more randomized placement
  rotateX(radians(90)); //placing image upright
  
  transparency = map(val, 0, 200, 255, 0);
  tint(225, 200, 255, transparency);

  image(boat, 0, 0, 40, 50); //image size
  popMatrix();
    }
  } 
}

void SUN(){
  //for (int y = 0; y < rows-1; y=y+4) { //adjusting end number:
    //for (int x = 0; x < columns; x=x+2) { //effects amount of people (less is more?)
  pushMatrix();
  translate(480, 369, 183); //more randomized placement
  rotateX(radians(90)); //placing image upright
  
  transparency = map(val, 0, 200, 0, 255);
  tint(255, 255, 255, transparency);
  
  image(sunbaby, 0, 0, 200, 160); //image size
  popMatrix();
}